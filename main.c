#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <windows.h>

//符号
 
   //课程目标
//深刻认识C语言重点操作符
//深度理解后置++
//深度理解负数取模（重难点）




//一、注释符号
  
  //一共有两种：双斜杠（这是C++风格的注释）
  //另一种是斜杠星号，星号斜杠（这是C语言风格的注释）

////注释之后，编译器会将做注释的地方直接删除，仅保留一个空格的位置
//in/* */t  a;
////这个在编译器看来就是in t a;  所以自会编译错误

//int/*   */i;
////在编译器看来也就是int i;//所以这个是正确的


//#define //这里面的#   和   define   可以之间有空格，分开写是可以的

//注意：注释在编译器中是会被替换的，本质是替换成空格（这个需要在Linux中演示）

//C语言风格的斜杠星号，星号斜杠有匹配的规则，这个规则与if else 匹配规则相同（总是与离它最近的相匹配）

//例如：
//y = x / *p;
  //千万不敢理解成注释的左半边

//int main()
//{
//	int x = 10;
//	int y = 0;
//	int z = 5;
//	int* p = &z;
//	y = x /(*p);//这里建议带一个括号
//	return 0;
//}


//注释规则：
  //1、注释应当准确、易懂，防止有二义性。错误的注释不但无益，反而有害
  //2、边写代码边注释，修改代码的同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要及时删除
  //3、注释是对代码的“提示”，而不是文档。程序中的注释应当简单明了，注释太多了会让人眼花缭乱
  //4、一目了然的语句不加注释
  //5、对于全局数据（全局变量、常量定义等）必须要加注释
  //6、注释采用英文、尽量避免在注释中使用缩写，特别是不常用的缩写
        //因为不一定所有的编译器都能显示中文，所以别人打开你的代码，你的注释也许是一团乱码。
        // 还有，你的代码不一定是懂中文的人在阅读
  //7、注释的位置应与被描述的代码相邻，可以与语句在同一行，也可以写在上行，但不可放在下行。同一结构中的不同
        //域的注释要对齐
  //8、当代码比较长时，特别是多重嵌套时，应当在一些段落的结束处加注释，便于阅读。
  //9、注释的缩进要与代码的缩进一致
  //10、注释代码段时应注意“为何做（why）”,而不是“怎么做（how）”
      //说明怎么做的注释一般停留在编程语言的层次，而不是为了说明问题。尽力阐述“怎么做”的注释一般没有告诉
        //我们操作的意图，而指明“怎么做”的注释通常时冗余的。
  //11、数值的单位一定要注释
  //12、对于变量的范围给出注释，尤其是参数
  //13、对一系列的数字编号给出注释，尤其在编写底层驱动程序的时候（比如引脚编号）
  //14、对于函数的入口/出口数据、条件语句、分支语句给出注释
  //15、避免在一行代码或表达式的中间插入注释
  //16、复杂的函数中，在分支语句、循环语句结束之后需要适当的注释、方便区分各分支或循环体
  //17（这个不推荐）、对于不需要被编译的区域要使用条件编译来实现，例如：使用带有注释的#if或#ifdef结构
        //由于C语言不支持嵌套护士，所以使用注释符达到这个目的的是不安全的，而且任何在该区域已经存在
        //的注释符都可能会影响最终结果
  //这个出现了一个条件编译，写大的项目的时候，有些要充钱，这就在代码中体现出条件编译的作用
    //当充了钱之后，条件语句之间的就以可以用，否则，条件语句之间的功能就不能用


//二、接续符和转义符
  //这里就是反斜杠的概念

//续航符

//int main()
//{
//    int a = 1;
//    int b = 2;
//    int c = 3;
//    //if (1 == a && 2 == b && 3 == c)//这里是只有三个，当这个并列居多的时候，就可以用到反斜杠了
//    //这里的\的作用是用作续航的功能
//    //在续航符之前可以加空格，但是在续航符之后，什么也不要加，连空格也不要加，一加就错误
//    //直接换行也可以，只是省略了换行符，加个续航符就是要告诉别人我要换行
//    if(1 == a &&\
//       2 == b &&\
//       3 == c)
//    {
//        printf("you can see me!");
//    }
//    else
//    {
//        printf("you can not see me!");
//    }
//    return 0;
//}



//转义字符

////想输出双引号，就得用到转义字符
//int main()
//{
//    printf("\"");
//    return 0;
//}


//反斜杠的作用：1、续航符使用，用在代码比较长的地方
             // 2、转义字符，  2.1  字面转特殊 n->\n
                         //    2.2  特殊转字面 """->"\""


//回车 和 换行
  //并不是一回事，回车的意思是：就光标是回到当前行的最开始
               // 换行的意思是：就是光标移动至下一行

//在C语言中，回车所对应的是  \r
           //换行所对应的是  \n


////旋转光标
//  //一个很简单的回车换行的例子
//int main()
//{
//    int index = 0;
//    const char* lable = "|/-\\";//这里看似写了五个字符，但其实只有四个字符
//    while (1)
//    {
//        index %= 4;//只有四个，保证lable中不越界
//        //printf("[%c]\n", lable[index]);//这里用的是\n所以每次都是换行
//        printf("[%c]\r", lable[index]);
//        index++;
//       Sleep(300);
//    }
//    return 0;
//}

//倒计时
//   也是一个回车与换行的概念
//int main()
//{
//    int i = 9;
//    for (; i >= 0; i--)
//    {
//        //printf("[%d]\n", i);//这里进行倒计时的时候就是进行的换行
//        printf("[%2d]\r", i);//这个就不会出现换行了，进行覆盖上次的输出
//        Sleep(300);
//    }
//    return 0;
//}



//三、单引号和双引号

//int main()
//{
//    //" "双引号通常是放的是字符串
//    //' '单引号通常是放的是字符 
//
////但是呢：
//    //"";//这代表的是空字符串
//    //"a";//这个是可以的，把单独的a看成字符串，后面是含\0的
//    //"abcd";//这个更不用说，这个是字符串abcd，后面是含\0的
//    //'a';//这个是字符a
//    //'abc';//这个也是可以编译过的，只是不推荐这样子的，只是这种是有报错的
//    //'';//这个就不可以直接保存，对于单引号表字符来说一定得有字符
//
//    printf("%d\n", sizeof(1));//1是整数 所以是4
//    printf("%d\n", sizeof("1"));//这里是字符串，大小是2，一个是1，一个是\0
//    
//    printf("%d\n", sizeof('1'));// 4，单引号是字符，例如：'a'叫做整型字符常量（integer character constant）
//                                    //是被编译器看成是int型
//                             //在C++中，这里就会被编译成 1，为1个字节
//    //在其他语言中呢，这个是要根据编译器的不同导致的数据不同
//    char c = '1';   //这里是将4个字节的数据写到了1个字节中，所以发生了截断
//                  //截断  就是将字节数大的放到了字节数小的中
//    printf("%d\n", sizeof(c));//  1
//
//    printf("%d\n", sizeof(""));//这里的大小是1，也就是可以理解成有一个\0
//    //printf("%d\n", sizeof(''));//这里就是编译错误
//    
//    char c = 'abcx';
//    //当这里写成4个字符的时候，编译器就不会报错的，四个及四个以下
//    //当写到第五的时候，编译器就会报错
//    //编译器给单引号分配的空间就只有四个字节，所以超过4的时候编译器就会报错，这里是及不推荐的
//    
//    return 0;
//}


//为什么会出现ASCII码表

  //C语言主要是由美国人发明的，英文就是26个字母构成单词，再由单词加标点符号构成语句，再由语句和标点符号
     //构成段落，再由段落构成文章
  
  //在计算机中的内存中存储的都是二进制数据，内存中进行的是二进制的加减法，当然不能在显示屏上输出二进制
//这样子的话用户是非常不满意的，为了满足用户的需求，所以人家做了一个简单的“映射”

//由系统来提供一张表。这张表包含我们各种原生字符和二进制之间的一种对应关系
  //例如：计算机中存储的是0000 1000，给这个标定一个8，而这个8，是一种符号，图形
//所以这样给显示器中，显示器输出的就是8,这种映射计算机不是很关心，它只关心如何映射，
  //在显示中，要是需要显示，就会用到ASCLL码表，要是不需要显示器显示，则就不会用到ASCII表
//ASCII表存在得价值：
    //1、本质上就是为了让我们对二进制数据映射转换成我们显示器当中的内容，供我们来阅读
 //2、ASCLL码表为何是现在这个样子？？
    //英文中不是像汉字一样那么多，弄来弄去，也就二百多个，凑来凑去，就凑出256个弄成一张表
   //将这个定义成UTF-8
  
   //例如像手机将简体中文改成繁体中文，当一设置之后，就相当于手机系统就改了一张映射表，所以就会变得如此之快


//int main()
//{
//    printf("%d\n", '0');//48
//    char c = 48;
//    printf("%c\n", c);//0   //这里的0不是数字0，而是字符0
//         //    \0 才是真正意义上的0值
//    return 0;
//}



// 四、逻辑运算符
  
//  1、&&（逻辑与）
  //级联两个（或多个）逻辑表达式，必须同为真，结果才为真
    //与  &  （按位与） 是不同的概念
//int main()
//{
//    int i = 0;
//    int j = 0;
//    if ((++i > 0) && (++j > 0))//这里是前置++，先++再使用
//    {
//        printf("yon can see me!\n");
//    }
//    printf("%d %d\n", i, j);//1 1
//    return 0;
//}


//  2、 || （逻辑或）

//级联两个（或多个）逻辑表达式，必须至少一个为真，结果才为真
  //与 | （按位或） 是不同的概念


//int main()
//{
//    int i = 0;
//    int j = 0;
//    if ((++i > 0) || (++j > 0))//前面成立就直接执行了，后面的没执行，把这个叫做短路
//    {
//        printf("yon can see me!\n");
//    }
//    printf("%d %d\n", i, j);//1 0
//    return 0;
//}


//短路：上面的一个条件不满足，已经不需要再看后续的条件的情况，就叫做短路，并且都是从左至右执行

//int show()
//{
//    printf("you can see me!");
//    return 1;
//}
//
//int main()
//{
//    int flag = 0;
//    printf("please Enter:");
//    scanf("%d", &flag);
//    //flag && show();//扫描的过程是从左至右
//    flag || show();
//    return 0;
//}



// 五、位运算符

//int main()
//{ 
//                // 10  11
//    printf("%d\n", 2 | 3);//按位或
//          //一定是二进制，相应位上，同为0则为0，其他都为1
//    printf("%d\n", 2 & 3);//按位与其他都为0
//             //相对应位上，同为1，则为1，
//    printf("%d\n", 2 ^ 3);//按位异或   
//             //相异为1，相同为0
//    printf("%d\n", ~0);//逻辑反
//            //00000000000000000000000000000000->11111111111111111111111111111111（32个0，32个1）
//      //%d打印的是有符号位，所以这里打印的是-1
//    //符号位要不要参与，符号位一定是要参与的
//    return 0;
//}

   //5.1   关于^(异或)

//基本理解
  //^:逐比特位，相同为假，相异为真
  //^:支持结合律和交换律
  //任何数和0异或，都是它本身

//int main()
//{
//    printf("%d\n", 4 ^ 3);
//    //这里都是32个比特位的
//       //4: 100
//       //3: 011
//       //^: 111   ==   7
//    printf("%d\n", 5 ^ 4 ^ 5);
//    printf("%d\n", 5 ^ 5 ^ 4);//这两个是等价的，这里可以看出是满足交换律
//                              //随意给两个带个括号，就满足了结合律
//       //5: 101
//       //4: 100
//       //^: 001
//       //5: 101
//       //^: 100 == 4
//    //这里就出现了一个运算规则：从左到右依次异或，除非带括号
//    printf("%d\n", 4 ^ 0);
//       //4: 100
//       //0: 000
//       //^: 100  == 4
//    return 0;
//}



//   //问题：如何完成两个整数的交换
//int main()
//{
//    ////方法一：创建临时变量
//    //int a = 20;
//    //int b = 30;
//    //printf("before:%d %d\n", a, b);
//    //int temp = a;
//    //a = b;
//    //b = temp;
//    //printf("after: %d %d\n", a, b);
//
//
//    ////方法二：不创建临时变量（交换数据时的加减法规则）
//    //int a = 20;
//    //int b = 30;
//    //printf("before:%d %d\n", a, b);
//    //a = a + b;//a=20+30=50
//    //b = a - b;//b=50-30=20
//    //a = a - b;//a=50-20=30
//    //printf("after: %d %d\n", a, b);
//    //  //这里会有一些问题，倘若a和b的值特别大，放不进去，这里就会发生截断的问题，截断本身就是对数据的一种丢弃
//    //  //  可能会有溢出问题
//    //  // 1、VS2013暂时没有办法复现问题
//    //  // 2、站在二进制角度，为什么会出现溢出的问题？
//    //  //     其实就是比特位太多，放不下。原因是加法可能产生进位。溢出就发生了截断
//    
//    ////方法三：（异或来解决）
//    //int a = 30;
//    //int b = 10;
//    //printf("before:%d %d\n", a, b);
//    //a = a ^ b;
//    //b = a ^ b;
//    //a = a ^ b;
//    //printf("after: %d %d\n", a, b);
//    ////为什么能完成交换呢？
//    //a = a ^ b;
//    //  //30:  11110
//    //  //10:  01010
//    //  //^ :  10100
//    //b = a ^ b;
//    //  //a :  10100
//    //  //b :  01010
//    //  //^ :  11110
//    //a = a ^ b;
//    //  //a :  10100
//    //  //b :  11110
//    //  //^ :  01010
//
//    ////还有一种：
//    //a = a ^ b;
//    //b = a ^ b;
//    //a = a ^ b;
//    ////结合律：
//    //b = a ^ b ^ b;
//    //a = a ^ b ^ a ^ b ^ b;
//
//    //此处异或会不会出现溢出呢？
//      //由于异或没有进位，所以绝对不会发生溢出问题
//    return 0;
//}

//相应运算，进位，溢出等概念都是会被记录到寄存器中的相应的比特位中
  //在写回内存时，才会发生截断问题



//相关规则：1、位操作需要用宏定义好后再使用的
       //常用的位操作宏：
                        //#define SETBIT(x,y)    ((x)|=(y))
                        //#define CLRBIT(x,y)    ((x)&=~(y))//要十分小心y是否是有符号数
                        //                                  //建议不要使用取反操作，而是
                        //                                  //自己计算需要的值，否则非常容易出错
                        //#define TOGLBIT(x,y)   ((x)^=(y))
                        //#define TESTBIT(x,y)   ((x)&(y))


//将特定比特位置1

//0 | 0 , 0 | 1 : 任何数字和0 | 都保持不变
//1 | 1 ，0 | 0 ：任何数字和1 | 结果是被设置为1

////#define SETBIT(x,n) (x | (1<<(n-1)))  //这种属于没有被赋值，所以这里就一直没有被改变
//#define SETBIT(x,n) (x |= (1<<(n-1)))
//
//void ShowBits(int x)
//{
//    int num = sizeof(x) * 8 - 1;
//    while (num >= 0)
//    {
//        if (x & (1 << num))//进行左移，左移31位,判断的是最高位，左移1位，判断的是第2位
//        {
//            printf("1 ");
//        }
//        else
//        {
//            printf("0 ");
//        }
//        num--;//从最高位开始进行判断
//    }
//    printf("\n");
//}
//int main()
//{
//    int x = 0;
//    //1、设置指定比特位为1
//    SETBIT(x, 5);//0000 0000 0000 0000 0000 0000 0000 0000 
//    SETBIT(x, 4);//对任意比特位进行更改
//         //后面的数字是对第几个比特位进行修改
//    //2、显示int的所有比特位
//    ShowBits(x);
//    return 0;
//}

//这里不好想，对于按位与，或，异或都是不好想的


//将特定比特位置0

//0 & 1 = 1 ,0 & 0 = 0

//10101010101010101101
//11111111111111110111    -->     //00000000000000001000 //进行按位取反  //要这样的比特位才可以

//#define CLRBIT(x , n) (x &=(~(1<<(n-1))))
//                          //(1<<(n-1))  这个就是拿到了11111111111111110111 序列，现在进行按位取反
void ShowBits(int x)
{
    int num = sizeof(x) * 8 - 1;//最高位是从0开始的
    while (num >= 0)
    {
        if (x & (1 << num))//进行左移，左移31位,判断的是最高位，左移1位，判断的是第2位
        {
            printf("1 ");
        }
        else
        {
            printf("0 ");
        }
        num--;//从最高位开始进行判断
    }
    printf("\n");
}
//int main()
//{
//    int x = 0xFFFFFFFF;//这是成16进制
//    ShowBits(x);
//    CLRBIT(x, 1);//从右向左
//    CLRBIT(x, 2);
//    CLRBIT(x, 3);
//    CLRBIT(x, 32);
//    ShowBits(x);
//    return 0;
//}



//六、整型提升

//int main()
//{
//    char c = 0;
//    printf("sizeof(c):%d\n", sizeof(c));                //1
//    printf("sizeof(c):%d\n", sizeof(~c));               //4
//    printf("sizeof(c):%d\n", sizeof(c << 1));           //4
//    printf("sizeof(c):%d\n", sizeof(c >> 1));           //4
//    printf("sizeof(c):%d\n", sizeof(！c));//逻辑反      //1
//      //sizeof（关键字），转到反汇编的时候发现，在编译的时候，已经将其转换成大小了
//    return 0;
//}

//无论任何位运算符，目标都是要计算机进行计算的，而计算机中只有CPU具有运算能力（先简单这样理解），但计算的
  //数据，都存放在内存中，故，计算之前（无论任何运算），都必须将数据从内存拿到CPU中，拿到CPU哪里呢？？
  //毫无疑问，在CPU寄存器中。
//而寄存器本身，随着计算机位数的不同，寄存器的位数也不同。一般，在32位下，寄存器的位数是32位
//可是，你的char类型数据，只有8比特位，读到寄存器中，只能填补低8位，那么高24位呢？？
//这时就需要用到“整型提升”了、

//在Linux 中，逻辑反是4，但是在上面个的VS中却是1


//七、左移，右移

  //  << (左移) ：最高位丢弃，最低位补零
  //  >> (右移) ：
              //  1、无符号数：最低位丢弃，最高位补零    （逻辑右移）
              //  1、有符号数：最低位丢弃，最高位补符号位（算术右移）

        //和内部保存的数据无关，任何关系都没有

//int main()
//{
//    //有符号数
//    //signed int x = 0xFFFFFFFF;
//    signed int x = 0xFFFFFFFE;//E为0
//    ShowBits(x);
//    //x << 1;//左移右移跟原反补是没有关系的，左右移就是在内存级别对补码的直接运算
//           //只有当数据被写入，或者数据被读取的时候，才跟原反补有关系
//    //这样子写，只是在内存级别进行了运算，但是并没有将其进行赋值给另一个变量
//    x = x >> 1;
//    ShowBits(x);
//    return 0;
//}



//如何丢弃：
  //基本理解链：
      // << 或 >> 都是计算，都要在CPU中进行，可是参与移动的变量，是在内存中的
   //所以需要先把数据移动到CPU内寄存器中，在进行移动
   //那么，在实际移动的过程中，是在寄存器中进行的，即大小固定的单位内。那么，左移右移一定会有位置
//跑到“外边”的情况


////相关练习：
//int main()
//{
//    //左移：
//    unsigned int a = 1;       //01          //无符号
//    ShowBits(a);
//    printf("%u\n", a << 1);   //010   == 2
//    ShowBits(a << 1);
//    printf("%u\n", a << 2);   //0100  == 4
//    ShowBits(a << 2);
//    printf("%u\n", a << 3);   //01000 == 8
//    ShowBits(a << 3);
//    printf("----------------------------------------------------\n");
//    //%u  无符号打印
//
//    //逻辑右移：
//    //无符号
//    unsigned int b = 100;     //0000 0000 0000 0000 0000 0000 0110 0100        
//    ShowBits(b);
//    printf("%u\n", b >> 1);   //0 0000 0000 0000 0000 0000 0000 0110 010  == 32+16+2 == 50
//    ShowBits(b >> 1);
//    printf("%u\n", b >> 2);   //00 0000 0000 0000 0000 0000 0000 0110 01  == 16+8+1 == 25 
//    ShowBits(b >> 2);
//    printf("%u\n", b >> 3);   //000 0000 0000 0000 0000 0000 0000 0110 0  == 8+4 == 12
//    ShowBits(b >> 3);
//    printf("----------------------------------------------------\n");
//    
//    
//    
//    //算术右移，最高位补符号位1，虽然移出了最低位1，但是补0还是1  //补的是符号位，就是1
//    int c = -1;
//    //1111 1111 1111 1111 1111 1111 1111 1111  //-1是32个1
//    ShowBits(c);
//    printf("%d\n", c >> 1);   
//    ShowBits(c >> 1);
//    printf("%d\n", c >> 2);
//    ShowBits(c >> 2);
//    printf("%d\n", c >> 3);
//    ShowBits(c >> 3);
//    printf("----------------------------------------------------\n");
//    //是算术右移，还是逻辑右移？最高位补0，为何？
//      //左侧是无符号数，右侧是有符号整数，但是呢是没有任何报错
//    //原因是：不管是给有符号数还是无符号数，赋值的时候，其中呢，在赋值的时候，要先将-1转换成二进制序列
//      //与无符号unsigned int d无半毛钱关系，只是将-1转换成二进制序列，d的类型在读取的时候才会起效果
//    //这里在右移的时候，最高位是看这个01序列的符号位，还是看d的类型
//      //答案是看的是d的类型
//    unsigned int d = -1;
//    ShowBits(d);
//    printf("%d\n", d >> 1);
//    ShowBits(d >> 1);
//    printf("%d\n", d >> 2);
//    ShowBits(d >> 2);
//    printf("%d\n", d >> 3);
//    ShowBits(d >> 3);
//    printf("----------------------------------------------------\n");
//    return 0;
//}


////问：0x01<<2+3的值是多少？
//int main()
//{
//    printf("%d\n", 0x01);
//    ShowBits(0x01);
//    printf("%d\n", 0x01 << 2 + 3);
//    ShowBits(0x01 << 2 + 3);//这里可以看出+的优先级比<<的优先级高
//    printf("%d\n", 0x01 << (2 + 3));
//    ShowBits(0x01 << (2 + 3));
//    printf("%d\n", (0x01 << 2) + 3);
//    ShowBits((0x01 << 2) + 3);
//    return 0;
//}//这个是比较简单的



//八、 ++、--操作

//int main()
//{
//    int a = 10;
//    int b = ++a;//   先自增，再赋值
//    printf("%d %d\n", a, b);
//    int c = a++;//   先使用，再自增
//    printf("%d %d\n", a, c);
//    c++;          //没有接受方，那么“先使用”，如何理解？
//                //有接收方，就赋值，没接收方，就直接使用
//    printf("%d\n", c);
//    return 0;
//}


//int main()
//{
//    //int a = 8;   //这是进行初始化
//    //int b = a++;//进入汇编语言
//    //          //会发现eax，所以这步运算是在CPU寄存器中进行运算的
//    ////    002F508C  mov         eax, dword ptr[a]    
//    ////    002F508F  mov         dword ptr[b], eax    //这里是先使用(两行)
//    ////    002F5092  mov         ecx, dword ptr[a]    //放在寄存器ecx中，ecx(计数器)
//    ////    002F5095  add         ecx, 1
//    ////    002F5098  mov         dword ptr[a], ecx    //这里是进行的运算（三行）
//
//
//  
//    int a = 8;
//        //    00E65085  mov         dword ptr[a], 8     //这里是将8放在了前面ptr[a]中
//
//    a++;
//        //    00DA508C  mov         eax, dword ptr[a]   //这个是将a的值放在eax中
//        //    00DA508F  add         eax, 1              //把a的值放在寄存器eax中。eax（累加器）
//        //    00DA5092  mov         dword ptr[a], eax  //将eax中的值再次放在a中
//    ++a;
//        //在汇编语言中，也是上面这三行代码，没有接受方，这里两个都是一样的
//     
//   //最典型的用处就是
//    //for (i = 0; i < 10; i++ / ++i)
//
//   //在汇编语言中，赋值就需要两行汇编
//    return 0;
//}

//结论：a++完整的含义是先使用，在自增。如果没有变量接收，那么直接自增(或者所谓使用，就是读取进寄存器，然后没有
//    然后)。
//    备注：不同的编译器可能处理过程不同，不过我们有一个基本研究过程，要比单纯理论学习更严谨。目前就这样理解。



////下面代码有严重问题，强烈不建议这样子写
//int main()
//{
//    int i = 1;
//    int j = (++i) + (++i) + (++i);
//    printf("%d\n", j);//这里是12，但是这行代码在不同的编译环境是有着不同的值的
//                      //VS中应该是先进行三次++i，成为4放进内存中，然后再从内存中加三次，加到的结果再放到内存中
//                      //在Linux中，这行代码的值是10
//                      //Linux中应该是先将前面两个i相加，之后成3，再两个（++i）成为6，再加第三个i（4）为10
//    return 0;
//}


//在编译复杂运算的时候，编译器会出现一种计算规则：贪心规则（贪心算法）(目的不是为了对，而是为了贪)
     //C语言中有这样一个规则：每一个符号应该包含尽可能多的字符，也就是说，编译器将程序分解成符号的方法是，
  //从左到右一个一个字符的读入，如果该字符可能组成一个符号，那么再读入下一个字符时，判断已经读入的两个字符
  //组成的字符串是否可能是一个符号的组成部分；如果可能，继续读入下一个字符，重复上述判断，直到读入的字符组成
  //的字符串已不再可能组成一个有意义的符号。这个处理的策略被称为“贪心法”。需要注意的是，除了字符串与字符串
  //常量，符号的中间不能嵌有空白（空格，制表符，换行符等），比如：==是单个符号而= =是两个符号

//int main()
//{
//    int i = 20;
//    int j = 10;
//    printf("%d\n", i++ + 10);//加个分号，编译器就会自动进行一定的分隔
//    printf("%d\n", i++++ + 10);//这里是报错的，并不是所有的贪心都能编译出来
//    printf("%d\n", i++ + ++j);//这样子就可以，贪心只是一种规则，并不代表着规则一定正确
//    return 0;
//}



// 九、 2/(-2)的值是多少，深度理解取余/取模运算

//9.1  关于“取整”你得知道


//    //第一种取整方案：C语言取整，默认是0向取整
//#include <math.h>
//int main()
//{
//    //int a = 5;
//    //int b = -5;
//    //printf("%d,%d\n", a, b);
//    //printf("%d,%d\n", a / 2, b / 2);
//
//
//    //本质是 向  0  取整
//    int i = -2.9;
//    int j = 2.9;
//    printf("%d\n", i);//结果是：-2
//    printf("%d\n", j);//结果是：2
//    printf("%d\n", (int)trunc(2.9));//trunc函数就是所谓的向0取整函数
//    printf("%d\n", (int)trunc(-2.9));
//    return 0;
//}


//////第二种取整方法：向负无穷大取整
//#include <math.h>
//int main()
//{
//    //这里都是取小了
//    printf("%.lf\n", floor(-2.9));//-3
//    printf("%.lf\n", floor(-2.1));//-3
//    printf("%.lf\n", floor(2.9)); //2
//    printf("%.lf\n", floor(2.1)); //2
//    return 0;
//}

////第三种取整方法：向正无穷取整
//#include <math.h>
//int main()
//{
//    printf("%.lf\n", ceil(-2.9));//-2
//    printf("%.lf\n", ceil(-2.1));//-2
//    printf("%.lf\n", ceil(2.9)); //3
//    printf("%.lf\n", ceil(2.9)); //3
//    return 0;
//}


////第四中取整方法：四舍五入进行取整
//#include <math.h>
//int main()
//{
//    printf("%.lf\n", round(-2.9));  //-3
//    printf("%.lf\n", round(-2.1));  //-2
//    printf("%.lf\n", round(2.9));   //3
//    printf("%.lf\n", round(2.1));   //2
//    return 0;
//}

//结论：浮点数（整数/整数），是有很多的取整方式的


//  9.2     取模的那些事

//取模的概念：
    //如果a和b是两个自然数，d非零，可以证明存在两个唯一的整数q和r，满足a=q*d+r,且0<=r<d，其中，q被称为商，
//r被称为余数

//int main()
//{
//    int a = -10;
//    int b = 3;
//    printf("%d\n", a / b);//这里是-3
//    printf("%d\n", a % b);//打印出来是-1，这是为什么呢
//    //上面概念说的取模要>=0，但是输出出来的却是负数，有问题
//
//
//    //在Linux中，与上面的打印结果是一样的
//    //在Python中，第一个打印出来是-4，第二个打印出来是2
//    return 0;
//}

//在python中概念是满足的，但是在C语言中就不满足了
//于是对取模出现了一个修正版的定义：
    //如果a和b是两个自然数，d非零，可以证明存在两个唯一的整数q和r，满足a=q*d+r,且0<=|r|<|d|，其中，q被称为商，
//r被称为余数

//解释C: -10 = (-3) * 3 + (-1)
//解释Python： - 10 = （ ? ） * 3 + 2, 其中，可以推到出来, '?'必须是 - 4(后面验证).即 - 10 = （ - 4） * 3 + 2，
//才满足定义。

//所以在不同的语言中，同一个计算表达式，负数“取模”结果是不同的，我们可以称之为分别叫做正余数和负余数

//9.3   是什么决定了这种现象  
    //具体取决于商，而商呢，取决于除法规则的时候，取整规则

//C语言中，可以发现，除法是向0取整
//python中，可以发现，除法是向负无穷取整


//9.4 取余和取模一样吗？？

//细心的同学，应该看到了，我上面的取模都是带着""的。说明这两个并不能严格等价(虽然大部分情况差不多)
//取余或者取模，都应该要算出商，然后才能得出余数。


//本质 1 取整：
//取余：尽可能让商，进行向0取整。
//取模：尽可能让商，向 - ∞方向取整。

//故：
//C中%, 本质其实是取余。
//Python中% ，本质其实是取模。（后面不考虑python，减少难度）

//理解链：
//对任何一个大于0的数，对其进行0向取整和 - ∞取整，取整方向是一致的。故取模等价于取余
//对任何一个小于0的数，对其进行0向取整和 - ∞取整，取整方向是相反的。故取模不等价于取余
//同符号数据相除，得到的商，一定是正数（正数vs正整数），即大于0！
//故，在对其商进行取整的时候，取模等价于取余。

//本质 2 符号：
//参与取余的两个数据，如果同符号，取模等价于取余


//9.5  如果参与运算是不同的符号呢？？

//int main()
//{
//    printf("%d\n", -10 / 3);//结果是：-3
//    printf("%d\n", -10 % 3);//结果是：-1，为什么？  -10=（-3）*3+（-1）
//
//    printf("%d\n", 10 / -3);//结果是：-3
//    printf("%d\n", 10 % -3);//结果是： 1   为什么？  10=（-3）*（-3）+1
//    return 0;
//}

//明显结论：如果不同符号，余数的求法，参考之前定义。而余数符号，与被除数相同



//我们不怎么严谨的数学推导，理解一下即可：
//重新看看定义：
//如果a和d是两个自然数，d非零，可以证明存在两个唯一的整数 q 和 r，满足 a = q * d + r, q 为整数，且0 ≤ | r |
//      < | d | 。其中，q 被称为商，r 被称为余数。
//    a = q * d + r 变换成 r = a - q * d 变换成 r = a + (-q * d)
//    对于：x = y + z，这样的表达式，x的符号 与 | y | 、 | z | 中大的数据一致（不好意思蛤，这是老哥想的定义）
//    而r = a + (-q * d)中， | a | 和 | -q * d | 的绝对值谁大，取决于商q的取整方式。

//    c是向0取整的，也就是q本身的绝对值是减小的。
//    如：
//    - 10 / 3 = -3.333.33 向0取整 - 3. a = -10 | 10 | , -q * d = -(-3) * 3 = 9 | 9 |
//    10 / -3 = -3.333.33 向0取整 - 3. a = 10 | 10 | , -q * d = -(-3) * (-3) = -9 | 9 |
//    绝对值都变小了

//    python是向 - ∞取整的，也就是q本身的绝对值是增大的。
//    - 10 / 3 = -3.333.33 '//'向 - ∞取整 - 4. a = -10 | 10 | , -q * d = -(-4) * 3 = 12 | 12 |
//    10 / -3 = -3.333.33 '//'向 - ∞取整 - 4. a = 10 | 10 | , -q * d = -(-4) * (-3) = -12 | 12 |
//    绝对值都变大了

//    结论：如果参与取余的两个数据符号不同，在C语言中(或者其他采用向0取整的语言如：C++，Java)，余数符号，
//          与被除数相同。


// 9.6 总结

//1、    浮点数(或者整数相除)，是有很多的取整方式的。
//2、    如果a和d是两个自然数，d非零，可以证明存在两个唯一的整数 q 和 r，满足 a = q * d + r, q 为整数，且0 ≤ 
// | r | < | d | 。其中，q 被称为商，r 被称为余数。
//3、    在不同语言，同一个计算表达式，“取模”结果是不同的。我们可以称之为分别叫做正余数 和 负余数
//4、    具体余数r的大小，本质是取决于商q的。而商，又取决于除法计算的时候，取整规则。
//5、    取余vs取模： 取余尽可能让商，进行向0取整。取模尽可能让商，向 - ∞方向取整。
//6、    参与取余的两个数据，如果同符号，取模等价于取余
//7、    如果参与取余的两个数据符号不同，在C语言中(或者其他采用向0取整的语言如：C++，Java)，余数符号，与被
//    除数相同。（因为采用的向0取整）



//优先级的先后顺序：
        //结构体->操作符    之后    前置++，后置++    再次    解引用*


